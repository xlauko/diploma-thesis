\chapter{DIVINE and friends}\label{ch:divine}

In this chapter we will look under the hood of the DIVINE~\cite{Divine17} the model checker.
On top of that, we will try to tackle problem of handling inputs by
symbolic model checking as introduced by Barnat et al.~in~\cite{Barnat14}. We will try to emphasize the
differences between classical model checking algorithm and symbolic algorithm,
in order to decompose symbolic part in following chapter.

For purpose of this thesis only minor knowledge of \DIVINE architecture is
needed. Our interest is mostly in the \LLVM interpreter (\DIVM) and exploration algorithm,
since only they interacts with a transformed program. Deeper description of \DIVINE can be found
in \cite{Divine17} or on project website
\href{https://divine.fi.muni.cz/}{divine.fi.muni.cz}.

\section{Model checking with \DIVINE}

\marginpar{Described architecture is of latest release \DIVINE 4.0.}

\DIVINE is a modular platform for verification of real world programs.
Overall architecture can be divided into 2 parts: a verification environment
that provides tools for \LLVM interpretation and state space exploration, and a
runtime environment, whose purpose is to give support of language features like
memory allocation, threads and standard libraries.

The verification and runtime environment are split into several components with
precisely defined interfaces between them, see \autoref{fig:architecture}.

The runtime part consists of user's program accompanied with necessary
libraries. For user's program is provided a \Cpp{} standard library and \textsc{posix} threading
library suited for \DIVINE interpreter. As environment for program is provided
a \DIVINE operating system (\DIOS) that provides support for thread management
and scheduling. For the communication between program and the operating system a set
of `syscalls` is provided by \DIOS.
The verification part consists of 2 main components: a \DIVINE virtual machine
(\DIVM) that interprets \LLVM bitcode and provides a state space generator, and
verification core that takes care of verification procedure.

\begin{figure}[!ht]

\resizebox{\textwidth}{!}{

\begin{tikzpicture}[>=stealth,shorten >=1pt,auto,node distance=4em, <->]

\tikzstyle{bcomponent} = [
     color=pruss,
    fill=white,
    thick,
    draw,
    text centered,
    minimum height= 1cm,
    minimum width=2.2 cm,
    text width=6 cm,
];

\node [bcomponent] (input) {User's program $+$ libraries};
\node [clabel, above = 0cm of input] (renv) {Runtime environment};
\node [bcomponent, below = 0cm of input] (runtime) {\Cpp{} standard libraries, \texttt{pthreads}};
\node [fnlabel, right = 1.7cm of runtime] (syslabel) {syscalls};
\node [color = pruss, left = 2cm of runtime] (divine) {\large\DIVINE};
\node [bcomponent, below = 0cm of runtime] (dios) {\DIOS};

\node [clabel, below = 0.4cm of dios] (venv) {Verification environment};
\node [fnlabel, left = 2.7cm of venv] (hyplabel) {hypercalls};
\node [bcomponent, below = 0cm of venv] (divm) {\DIVM};
\node [bcomponent, below = 0cm of divm] (vc) {Verification core};


\begin{pgfonlayer}{background}
     \node[runtime, outer, fit = (renv) (input) (runtime) (dios)] (runtimebox) {};
\end{pgfonlayer}

\begin{pgfonlayer}{background}
  \node[verification, outer, fit = (venv) (divm) (vc)] (verificationbox) {};
\end{pgfonlayer}

\draw [-,dashed, very thick, color = pruss] ([xshift=4cm]input.south east) -- ([xshift=-4cm]input.south west);
\draw [flow,rectangle connector=1.5cm] (input.east) to (dios.east);
\draw [flow,rectangle connector=0.75cm] (runtime.east) to (dios.east);

\draw [flow,rectangle connector=-1.5cm] (runtime.west) to (divm.west);
\draw [flow,rectangle connector=-0.75cm] (dios.west) to (divm.west);
\end{tikzpicture}
}

\caption{\DIVINE architecture is divided into two parts. A runtime environment
represents a \LLVM bitcode that is interpreted by \DIVM. And verification
component that provides model checking tooling. Communication between
layers is done by \texttt{syscalls} to \DIOS and by \texttt{hypercalls}
to \DIVM.}\label{fig:architecture}
\end{figure}

\section{\DIVINE virtual machine}

A \DIVINE virtual machine aims to provide a bare minimum for \LLVM-based
model checking. This involves execution of instructions, memory management,
nondeterministic choice and tracking of atomic sections. A deeper description of
\DIVM can be found in \cite{RockaiCB17}.
\marginpar{Nondeterministic choice serves for simulation of threads interleaving
and potential input generation.}

Side by side of \LLVM bitcode evaluation, \DIVM stores a representation of a
program state. A snapshot of a state can be passed to verification algorithm
for safety analysis. And vice versa the verification algorithm may ask \DIVM for
successors of a given state.
\add{ this is not how it works }


A program state is represented by memory configuration encoded to graph.
Nodes of the graph represent objects (e.g.~results of allocation, global
variables) and edges represent pointers between these objects.
\DIVM stores these states compressed and hashed, and compares the graphs
directly for state equality.

\DIVM in \DIVINE is accompanied by runtime environment, which is executed on top
of it. This environment is expected to provide a \emph{scheduler}, that is invoked
by \DIVM during generation of state successors. An interface between \DIVM and
runtime environment is provided by \emph{hypercalls}, that enable runtime to modify
memory and create state space branching by nondeterministic choice.

\begin{example}
A nondeterministic choice provided by \DIVM as \texttt{\_\_vm\_choose} function
gives an ability to create a branching in the state space. For example following nondeterministic
choice creates a successor state for each \texttt{n} from a given \texttt{range}.

\begin{minted}{cpp}
int n  = __vm_choose( range );
\end{minted}

\end{example}
\subsection{State space reductions}

In order to enable verification of real world programs \DIVINE needs to employ
some state space reduction technique. For this purpose a so called
$\tau$-reduction is implemented, to eliminate superfluous intermediate states,
and heap symmetry-based reduction \cite{Rockai13} \cite{RockaiCB17}. It is demanded
that state space reductions preserve all safety and \LTL properties verified
by \DIVINE.

In \LLVM, a large subset of instructions have no observable effect for other
threads. This holds for instructions that manipulate registers (registers
are private for the executed function) and those instructions that manipulate
only private memory of a thread.

Hence \DIVINE does not need to emit a new state on every interpreted
instruction, but only when an observable action is reached. In the resulting state
space, edges correspond to sequences of non-observable instructions.

In \DIVM, a support for the $\tau$-reduction is implemented by \code{interrupt\_mem}
and \code{interrupt\_cfl} hypercalls. These calls enables a signalization of an
observable action to state space generation and may cause an interrupt in edge
generation. The \code{interrupt\_mem} hypercall signals to \DIVM that a memory
operation is about to be executed.
\add{ check divm papre for precise definition }
For signalization of potential a loop in the
program state space \code{interrupt\_cfl} hypercall is used.
\subsection{Verification workflow}

Verification in \DIVINE is split into two phases, see \autoref{fig:verification}.
A preprocessing phase, where an input program is
transformed into suitable input for \DIVM. In second phase a transformed program
is processed by \DIVM and some verification algorithm.

Since most of this thesis extends the preprocessing part, let's have a closer
look into program transformations. The transformations are similar to \LLVM
optimization passes (they work in \LLVM -to-\LLVM manner). They modify an input
program in order to extend a model checker capabilities. For example a
verification of programs with weak memory models is done via a transformation
\cite{Still16}, verification of programs with exceptions \cite{Still17} and minor
optimizations like interrupts insertion for faster scheduling.

Transformations are made by external tool named \LART introduced in~\cite{Rockai15}
as LLVM Abstraction \& Refinement tool. The main motivation behind \LART is to
provide preprocessing for \LLVM -based verification tools, simplifying their
job by reducing the problem size without compromising soundness of the
verification.

As abstraction tool \LART was never fully implemented and till this thesis it
was meant only as a proof-of-concept. The main aim of this thesis is to provide
a core analysis for \LART to be able to inject an arbitrary abstraction into a
program.

\begin{figure}[!ht]

\resizebox{\textwidth}{!}{
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4em, <->]
\tikzset{>=latex}

    \tikzstyle{smt}=[fill=ucla!40]
    \node [component](cc) {\DIVINE compiler};
    \node [clabel, above = 0.7 cm of cc] (preprocessing) {Preprocessing};
    \node [component, right = 0.5 cm of cc](lart) {\LART};
    \node [emptycomponent, dashed, thick, below = 0.6 cm of cc] (dios) {\DIOS and libraries};

    \node [component, right = 0.6 cm of lart, ](interpreter) {Interpreter};
    \node [component, right = 0.5 cm of interpreter, minimum width=1 cm](generator) {State space generator};

    \node [component, below = 0.6 cm of generator, minimum width=1 cm](exploration) {Exploration algorithm};
    \node [clabel, right = 3 cm of preprocessing] (divine) {DIVINE};

    \node [right = 0.5 cm of exploration ] (res)
    {\color{apple}{Valid}\color{pruss}/\color{orioles}{Error}};

    \node [clabel, above = 0.9 cm of interpreter.west, anchor = west] (divml) {DiVM};
    \node[emptycomponent, dashed, fit = (interpreter) (generator) (divml)] (divm) {};

    \begin{pgfonlayer}{background}
        \node[runtime, outer, fit = (cc) (lart) (preprocessing)(dios)] (prepbox) {};
    \end{pgfonlayer}

    \begin{pgfonlayer}{background}
        \node[verification, outer, fit = (interpreter) (generator) (exploration) (divine) (divm) ] (di) {};
    \end{pgfonlayer}

    \node [left = 1.5 cm of cc, color=pruss] (start) {\Cpp{} program};
    \node [right = 2 cm of exploration] (end) {};
    \node [below = 2.3 cm of start, color=pruss, text width = 1.5 cm] (property) {\centering property and\\ options};

    \draw [flow] (cc) -- (lart);

    \draw [flow] (dios) -- (cc);

    \draw [flow] (lart) -- (interpreter);

    \draw [flow, <->] (interpreter) -- (generator);

    \draw [flow] (generator) -- (exploration);

    \draw [flow, dashed] (start) -- (clang);
    \draw [flow, dashed] (property) -| (interpreter);
    \draw [flow, dashed] (property) -| (lart);
    \draw [flow, dashed] (exploration) -- (res);
\end{tikzpicture}
}
\caption{Verification process in \DIVINE consists of preprocessing and
state space exploration. In preprocessing step an input code is
compiled and linked with \DIOS runtime and \DIVINE support
libraries. Then the bitcode is instrumented by \LART producing a suitable \LLVM bitcode with \DIVM hypercalls. And finally the bitcode is interpreted in \DIVM and the verification result is produced.}\label{fig:verification}
\end{figure}

\section{Symbolic model checking with \SymDIVINE}\label{sub:symdivine}

Since \DIVINE is an explicit state model checker, its big disadvantage are inputs. The
only way to handle inputs in \DIVINE is to enumerate all possibilities, leading to
enormous state space explosion. Hence current \DIVINE is usable only on
closed programs (programs without input). As an attempt to solve input problem a
\SymDIVINE was designed as an extension of \DIVINE. \SymDIVINE is
a proof-of-concept tool that is based on idea of \emph{control-explicit data-symbolic}
model checking \cite{Barnat14}.

\subsection{Control-explicit data-symbolic model checking}

In comparison to exhaustive enumeration of states by purely explicit approach, a
control-explicit data-symbolic approach tries to group states into sets, when
they differ only in data values but not in control location. In this way \SymDIVINE is able to
simulate inputs as sets of possible values. These sets, also called \emph{multi states}, are described by explicit control location and symbolic representation of
data, in our case by quantified \emph{smt} bit-vector formula (for better description see
\autoref{sec:multistates}). During model checking a state space exploration
algorithm works directly with multi states, hence the computation is more
time-consuming, since an \SMT solver has to be called in order to
distinguish states. On the other hand symbolic approach may bring
exponential memory savings and avoid state space explosion caused by inputs.

\subsection{Representation of multi states} \label{sec:multistates}

A challenging part of symbolic model checking is how to define a suitable
representation of states. Representation of control location (explicit part of
multi state) is straightforward. A model checker just needs to store
a program location for each thread. On the other hand coming up with a good
representation of symbolic data may be quite challenging. Since \DIVINE aims
for bit-precise verification a suitable choice is representation of data
by \emph{smt} bit-vector formulae~\cite{Bauch14}.

In order to manipulate with bit-vector formulae \SymDIVINE uses a theory over
\emph{fixed sized bit-vectors}. The theory over fixed sized bit-vectors is a many-sorted
first-order theory with infinitely many sorts $\sort{n}$ corresponding
to bit-vectors of length $n$. The only predicate symbols in the BV theory
are $=$, $\leq_u$, and $\leq_s$, representing
equality, unsigned inequality of binary-encoded natural numbers, and
signed inequality of integers in $2$'s complement representation,
respectively. Functions symbols in the theory are
$+, \times, \div, \&, \mid, \oplus, \ll, \gg, \cdot, \extract{n}{p}$,
representing addition, multiplication, unsigned division, bit-wise
and, bit-wise or, bit-wise exclusive or, left-shift, right-shift,
concatenation, and extraction of $n$ bits starting from position $p$,
respectively. For a precise description of the syntax and semantics of the bit-vector
theory, we refer the reader to Hadarean \cite{Hadarean14}. In this representation,
the set of represented memory valuations is precisely the set of satisfying assignments
to the given formula.

Since \SymDIVINE does not support dynamic memory allocation, representation
of symbolic data becomes much simpler. In representation via bit-vector
\SMT formulae, an unambiguous identification of symbolic variables is crucial.
Therefore \SymDIVINE uses names given by function
segment on stack and offset of given variable in the corresponding segment. \cite{Mrazek16}.
Manipulations with symbolic data are represented by corresponding functional symbols.

Besides remembering current values of variables, \SymDIVINE has to keep for
some variables previous evaluations (also called generations). This happens when
a value of symbolic variable depends on another symbolic variable, see \autoref{ex:gen}. Formally,
a multi state is a tuple $(c, m, \varphi)$, where $c$ is an explicit control part, $m$ is an
explicit memory shape and $\varphi$ is quantifier-free first-order formula over the theory of fixed size
bit-vectors.

\add{ citation to Honza + Martin na arxiv }

\begin{example}\label{ex:gen}
Having following C code \SymDIVINE has to store multiple generations of variable
\code{a}, because after the evaluation of all statements \SymDIVINE needs to know
that, \code{b} is equal to \code{a} from first line (first generation of
\code{a}) and \code{a} (in second generation) is equal to $0$.

\begin{minted}{cpp}
int a = 10;
int b = a;
a = 0;
\end{minted}

\end{example}

A symbolic representation of data is further structured into two parts -- a
program \emph{path condition} and data \emph{definitions}. The path condition is a
conjunction of formulae that represents a restriction of the data that have been
collected during branching along the path leading to the current location.
Definitions, on the other hand, are made of a set of formulae in the form
\emph{variable = expression} that describe internal relations among variables.
Definitions are produced as a result of an assignment or arithmetic
instructions. The structure of symbolic data representation allows for a
precise description of what is needed for model checking, but it lacks the
canonical representation. As a matter of fact, the equality of multi states
cannot be performed as a syntax equality, instead, \SymDIVINE employs \SMT
solver and quantified formulae to check the satisfiability of a path condition
and to decide the equality of two multi states \cite{Mrazek16}.

\subsection{State space exploration}

When program reads some input, an explicit state model checker emits a
new successor for every possible input value. It is good to remark that all of
these states differ only in a single value, but they occupy same control flow
location. Hence a same sequence of instructions is applied to them.

\marginpar{Nondeterministic input values for \SymDIVINE are introduced by
\texttt{\_\_VERIFIER\_nondet\_\{type\}}, where \texttt{\{type\}} defines type of
input value.}

On the other hand a symbolic approach emits only one multi state. We may look at
multi state as it represents a set of purely explicit states (defined by
set-based reducion~\cite{Havel14}). See an example \ref{ex:reduction} for comparison of
explicit state space and state space reduced by set-based reduction.

The only event that splits a state space of multi states is a control flow branching,
that depends on a symbolic value. This happens when a symbolic value is used in
some comparison (in \LLVM an \code{icmp} instruction). Consequently a pair of
multi states has to be generated, one that corresponds to state when the
comparison result was true and second when the result was false. Additionally,
according to comparison result corresponding values in multi states have
to be constrained based on comparison condition. For better explanation see
following example \ref{ex:reduction}.

\begin{example}\label{ex:reduction}
Let's have a look on the impact of set-based reduction on program with input and
branching. The corresponding \LLVM bitcode is on the right side.

\begin{center}
\begin{minipage}[t]{.47\textwidth}
\begin{minted}{cpp}
unsigned int I = input();
if (I >= 65535) {
    ...
} else {
    ...
\end{minted}
\end{minipage}\hfill
\begin{minipage}[t]{.47\textwidth}
\begin{minted}{llvm}
%i = call i32 @input()
%b = icmp uge i32 %i, 65535
%br i1 %b, label %t, label %e
\end{minted}
\end{minipage}
\end{center}

\bigskip
\noindent
In order to precisely verify a program with input, \DIVINE has to generate all
possible evaluations of \code{input} call. Hence the resulting state space suffers
from great state space explosion. We may notice that state space is branched when
the input call is executed, but following execution continues in sequential
manner.

\begin{centering}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[]
    \tikzstyle{every node}=[align=center, minimum width=1.25cm, minimum height=0.6cm]
    \tikzset{empty/.style = {minimum width=0cm,minimum height=1cm}}
    \tikzset{dots/.style = {draw=none}}
    \tikzset{>=latex}
    \node [pc, text width = 1 cm] (s) {$\bot$};
    \node [right = 3cm of s] (mid) {};

    \node [pc, above = -0.25 cm of mid, minimum width=2.7cm] (s65534){i = 65534};
    \node [pc, below = -0.25 cm of mid, minimum width=2.7cm] (s65535){i = 65535};

    \node [dots, above = 0 cm of s65534] (dots1){\LARGE$\vdots$};
    \node [dots, below = -0.2 cm of s65535] (dots2){\LARGE$\vdots$};

    \node [pc, above = -0.2 cm of dots1, minimum width=2.7cm] (s0) {i = 0};
    \node [pc, below = 0 cm of dots2, minimum width=2.7cm] (sn) {i = 2\^{}32 - 1};

    \node [pc, right = 1.5 cm of s65534, minimum width=4.3cm]
    (s65534_icmp){i = 65534; b = 0};
    \node [pc, right = 1.5 cm of s65535, minimum width=4.3cm]
    (s65535_icmp){i = 65535; b = 1};

    \node [dots, above = 0.0 cm of s65534_icmp] (dots1_icmp){\LARGE$\vdots$};
    \node [dots, below = -0.2 cm of s65535_icmp] (dots2_icmp){\LARGE$\vdots$};

    \node [pc, right = 1.5 cm of s0, minimum width=4.3cm] (s0_icmp)
    {i = 0; b = 0};
    \node [pc, right = 1.5 cm of sn, minimum width=4.3cm] (sn_icmp)
    {i = 2\^{}32 - 1; b = 1};

    \node [empty, left  = 1 cm of s]  (start) {};
    \node [empty, right = 1 cm of s0_icmp] (s0end) {};
    \node [empty, right = 1 cm of s65534_icmp] (s65534end) {};
    \node [empty, right = 1 cm of s65535_icmp] (s65535end) {};
    \node [empty, right = 1 cm of sn_icmp] (snend) {};

    \draw [flow] (s.east) -- (s0.west) node [near end, above=1pt, sloped] {\texttt{call}} ;
    \draw [flow] (s.east) -- (s65534.west) node [near end, above=1pt, sloped] {\texttt{call}} ;;
    \draw [flow] (s.east) -- (s65535.west) node [near end, below=1pt, sloped] {\texttt{call}} ;
    \draw [flow] (s.east) -- (sn.west) node [near end, below=1pt, sloped] {\texttt{call}} ;

    \draw [flow] (s0) -- (s0_icmp) node [midway, above=0pt] {\texttt{icmp}};
    \draw [flow] (s65534) -- (s65534_icmp) node [midway, above=0pt] {\texttt{icmp}};
    \draw [flow] (s65535) -- (s65535_icmp) node [midway, above=0pt] {\texttt{icmp}};
    \draw [flow] (sn) -- (sn_icmp) node [midway, above=0pt] {\texttt{icmp}};

    \draw [flow, dashed] (s0_icmp.east) -- (s0end) node [empty, midway, above=2pt] {};
    \draw [flow, dashed] (s65534_icmp.east) -- (s65534end) node [empty, midway, above=2pt] {};
    \draw [flow, dashed] (s65535_icmp.east) -- (s65535end) node [empty, midway, above=2pt] {};
    \draw [flow, dashed] (sn_icmp.east) -- (snend) node [empty, midway, above=2pt] {};

    \draw [flow, dashed] (start) -- (s);
\end{tikzpicture}
}
\end{centering}

\bigskip

\noindent
On the other hand, in \SymDIVINE the \code{input} call generates single multi state,
where '\code{i}' represents a set of all possible 32-bit values. State space is then
branched when a comparison instruction \code{icmp} is executed. In this case, two
possible scenarios may happen. First, when '\code{i}' is smaller than 65535, a multi
state with \code{b = 0}, as result of comparison, is generated. Similarly for second case, when
the condition is satisfied, a state with appropriately constrained '\code{i}' is generated.

\bigskip

\begin{centering}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[]
    \tikzstyle{every node}=[align=center, minimum width=1.25cm, minimum height=0.6cm]
    \tikzset{empty/.style = {minimum width=0cm,minimum height=1cm}}
    \tikzset{dots/.style = {draw=none}}
    \tikzset{>=latex}

    \node [pc, text width = 1cm] (s_sym) {$\bot$};
    \node [pc, text width = 3.7cm, right = 1.5 cm of s_sym, minimum width=2cm] (s_nd_sym)
    {i = \{0,\dots,2\^{}32 - 1\}};

    \node [empty, right = 4cm of s_nd_sym] (mid_sym) {};

    \node [pc, text width = 5cm, above = -0.45 cm of mid_sym, minimum width=5cm] (s1_sym)
    {i = \{0,\dots,65534\}\\b = \{0\}};
    \node [pc, text width = 5cm, below = -0.45 cm of mid_sym, minimum width=5cm] (s2_sym)
    {i = \{65535,\dots,2\^{}32 - 1\}\\b = \{1\}};

    \node [empty, left  = 1 cm of s_sym]  (start_sym) {};
    \node [empty, right = 1 cm of s1_sym] (s1end_sym) {};
    \node [empty, right = 1 cm of s2_sym] (s2end_sym) {};

    \draw [flow] (s_sym.east) -- (s_nd_sym.west) node [midway, above=0pt] {\texttt{call}};

    \draw [flow] (s_nd_sym.east) -- (s1_sym.west) node [midway, above=1pt,sloped] {\texttt{icmp}};
    \draw [flow] (s_nd_sym.east) -- (s2_sym.west) node [midway, below=1pt, sloped] {\texttt{icmp}};

    \draw [flow, dashed] (start_sym) -- (s_sym);
    \draw [flow, dashed] (s1_sym) -- (s1end_sym);
    \draw [flow, dashed] (s2_sym) -- (s2end_sym);
\end{tikzpicture}
}
\end{centering}

\end{example}

During state space exploration \SymDIVINE employs a \SMT solver for two tasks.
Firstly, in compare to \DIVINE, a detection of already visited state is much
more complicated. Comparison of two multi states is done by comparison of their
explicit part (i.e.~whether they are in same control location) and symbolic
part. Equality of symbolic part is achieved by subset comparison, i.e. the
symbolic parts are equal when one is subset of another and vice versa.
This subset comparison is encoded into \SMT formula and given to
\SMT solver.

The second use case of \SMT solver is when exploration algorithm needs to
determine whether a given state is reachable. This may be done by simple query
on satisfiability of path condition. For example if symbolic part of state is
represented by following formula: $x > 0 \wedge x < 0$, state is unreachable,
because formula is unsatisfiable. As a consequence \SymDIVINE does
not generate a given unreachable successor.

\subsection{Multi state equality check}\label{subsec:equality}

To distinguish two states in explicit model checking we just need to compare values of
given states explicitly, but in \SymDIVINE we need to determine whether the
multi states represents the same set of concrete states. For this purpose \SymDIVINE
uses a power of \SMT solver.

Let $s_1$ and $s_2$ are multi states with same explicit part. That is, when $s_1
= (c, m, \varphi)$ and $s_2 = (c, m, \psi)$ for control part $c$ and
memory shape $m$ and formulae $\varphi$ and $\psi$. Let $\free{\varphi} = \{x_1,
\dots, x_n\}$ and
$\free{\psi} = \{ y_1, \dots, y_m\}$ denote free variables of $\varphi$ and
$\psi$. Moreover, we denote the set of program variables at the control location
$c$ as $\pVars{c}$. The for each program variable $p$ exists a variable $x^p$ in
$\varphi$ that represents the last generation of the program  variable $p$ in
the multi state $s_1$. Analogously, the last generation of the program variable
$p$ in $s_2$ is represented by a variable $y^p$ in $\psi$.

To decide whether the sets of concrete states represented by $s_1$ and $s_2$ are
equal, \SymDIVINE uses a formula $\notsubseteq(s_1, s_2)$, which is satisfiable
precisely if there is a state represented by $s_1$ that is not represented by
$s_2$:

\[
  \notsubseteq(s_1, s_2) \defeq \varphi~\land~ \forall y_1 \ldots y_m
  \, \Big ( \psi \Rightarrow \bigvee_{p \in \pVars{c}} (x^p \not =
  y^p) \Big)
\]

The equality of two multi states is then decided by using an \SMT solver:
the states $s_1$ and $s_2$ are equal precisely if both of
formulas $\notsubseteq(s_1, s_2)$ and $\notsubseteq(s_2, s_1)$ are
unsatisfiable, i.e. there is no memory valuation that is represented
only by one of the multi-states. However, the equality check requires
a quantified \SMT query, which is usually more expensive than the
quantifier-free one.

\add{ add citation of Symdivine paper }

\subsection{Architecture of \SymDIVINE}
Talking about \SymDIVINE overall architecture, it mimics design of \DIVINE.
Generally a verification workflow consists of preprocessing part, where
generation of \LLVM bitcode and minor optimizations are done. In compare to
\DIVINE, symbolic approach does not assimilate \DIOS layer. Hence all scheduling
and memory management is done solely by verification core of \SymDIVINE. Except
that, we may distinguish 3 parts in verification core, an interpreter, a state
generator and exploration manager. They behave similarly as their \DIVINE
counterparts. In extension state space generator communicates with external
\SMT solver as described before.

\begin{figure}[!ht]
\centering
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4em, <->]
\tikzset{>=latex}

    \tikzstyle{smt}=[fill=ucla!40]
    \node [component](clang) {clang -emit-llvm};
    \node [clabel, above = 0.3 cm of clang] (preprocessing) {Preprocessing};
    \node [component, below = 0.5 cm of clang](lart) {LART};

    \node [component, right = 0.6 cm of lart, ](interpreter) {\LLVM interpreter};
    \node [component, right = 0.5 cm of interpreter, minimum width=1 cm](generator) {State space generator};

    \node [component, smt, right = 0.5 cm of generator, minimum width=1 cm, text width=1 cm](smt){\SMT solver};
    \node [component, above = 0.5 cm of generator, minimum width=1 cm](exploration) {Exploration algorithm};
    \node [clabel, right = 0.5 cm of preprocessing] (symdivine) {SymDIVINE};

    \node [right = 0.5 cm of exploration ] (res)
    {\color{apple}{Valid}\color{pruss}/\color{orioles}{Error}};

    \begin{pgfonlayer}{background}
        \node[runtime, outer, fit = (clang) (lart) (preprocessing)] (prepbox) {};
    \end{pgfonlayer}

    \begin{pgfonlayer}{background}
        \node[verification, outer, fit = (interpreter) (generator) (exploration) (symdivine) ] (preprocessing) {};
    \end{pgfonlayer}

    \node [left = 1.5 cm of clang, color=pruss] (start) {\Cpp{} program};
    \node [right = 2 cm of exploration] (end) {};
    \node [below = 2.3 cm of start, color=pruss] (property) {property};

    \draw [flow] (clang) -- (lart);

    \draw [flow] (lart) -- (interpreter);

    \draw [flow, <->] (interpreter) -- (generator);

    \draw [flow, <->] (smt) -- (generator);

    \draw [flow] (generator) -- (exploration);

    \draw [flow, dashed] (start) -- (clang);
    \draw [flow, dashed] (property) -| (generator);
    \draw [flow, dashed] (exploration) -- (res);
\end{tikzpicture}
}
\caption{ Verification workflow of \SymDIVINE is similar to \DIVINE{}'s. It consists
of two steps, a preprocessing part where a suitable \LLVM bitcode is created. In compare to
\DIVINE, compilation is done by unmodified compiler and \LART transformations
are used only slightly. We would like to note, that only verified program
attends a compilation process, since no \SymDIVINE proprietary runtime (as \DIOS) is
needed. On the other hand \SymDIVINE needs to simulate scheduling directly in
interpreter and state space generator. In compare to \DIVINE a verification part
of \SymDIVINE maintains similar architecture. The only big difference is
interface to external \SMT solver.}\label{fig:symdivine}
\end{figure}


\subsection{Drawbacks of \SymDIVINE}
Even though \SymDIVINE may sound as suitable instrument for verification of open
programs, it comes with couple of issues. First of all, since \SymDIVINE was
designed only as prototype tool, it does not provide full \Cpp{} language support
(i.e.~verification of program with exceptions). As consequence \SymDIVINE does
not provide support for \Cpp{} standard library. Moreover, \SymDIVINE aims only
for symbolic manipulation with integers, hence it does not provide full support
of \LLVM instruction set, especially memory manipulations, symbolic indices and

As drawback of unsupported operations is also that \SymDIVINE can not interpret
programs even with explicit memory manipulations. Another drawback that emerges
from monolithic architecture of \SymDIVINE is, that it is not easily expendable.
Consequently it is hard to maintain the core of the tool correct when adding the
new features. Lastly, since \SymDIVINE is only prototype tool, it was never
fully optimized, hence it was not capable to verify simple programs in reasonable
time.

We believe that, including the \SymDIVINE approach into the \DIVINE can get rid
of most of these drawbacks. Especially it enables full support of \LLVM and
\Cpp{} exceptions. Moreover, the explicit data can be handled explicitly by
tunned \DIVINE interpreter, hence the support for explicit memory can be
maintained.

\section{State of the art tools}

In addition to \SymDIVINE a symbolic model checking is known technique for a few
decades \cite{McMillan93}. There are well known symbolic model checkers such as
NuSMV -- a tool based on combination of \SMT and \BDD technique
\cite{Cimatti20}, or PRISM providing large variety of symbolic algorithms
\cite{Kwiatkowska20}.

A big disadvantage of these tools is that they do not accept a \Cpp{} as form of
an input model. Hence providing a symbolic algorithm for tool aimed on \Cpp{} is a
reasonable effort, also from the model checking community point of view.

But since this technique is widely known we would like to bring a new approach
of dealing with symbolic values. As it will be described in
\autoref{ch:abstraction}, we may approach to symbolic model checking from two
sides. In classical design the symbolic model checker interprets the program
in symbolic manner (i.e.~manipulates with symbolic representation of data). This
is the approach of \SymDIVINE and tools mentioned earlier. In the other approach
we may transform a program in such manner that it will behave symbolically (i.e.
the operations and data in program will directly represent the symbolic
manipulations), the transformed program is then processed by explicit
model-checker or another tool of our choice.

The similar approach to transformation was introduced by Khurshid et al.
\cite{Khurshid03} as approach to symbolic execution. They have instrumented a
Java code in such manner that the resulting code behaves as its variables were
symbolic, this code is then processed by Java PathFinder \cite{Havelund20}. We
have designed a similar approach, an abstraction via program transformation for
\LLVM programs in the \autoref{ch:abstraction}.
