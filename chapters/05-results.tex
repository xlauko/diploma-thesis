\chapter{Evaluation}\label{ch:results}

The resulting transformation is able to handle programs where only integer
arithmetic is abstracted. We provide ability for pointers to point on the
abstract values and structures to contain abstract elements. However we are
currently not able to insert abstract values into arrays and abstract pointers
(i.e. memory allocation). These limitations are caused by insufficient
representation of abstract data, in the case of arrays\sidenote{Currently, we
are not able to represent elements of arrays by shapes for abstract values. We
think this can easily implemented in a similar manner as abstraction of
aggregate types. Further limitations represent a runtime indices into the
arrays, which we are not able to compute during transformation.},
and missing pointer analysis in the case of pointers. For further evaluation we
have omitted programs that contain these unsupported characteristics.

Other technicalities, such as support of threading and support of full \Cpp{}
standard library remains untouched, since transformations do not interfere with
explicit computation of a program.

To show that the proposed approach is sufficient replacement of \SymDIVINE, we
will compare the symbolic transformation with \DIVINE as backend against \SymDIVINE.
Evaluation will be done on two sets of benchmarks -- subset of benchmarks from
software verification competition (\textsc{sv-comp})~\cite{Beyer17} and
benchmarks of data structures, concretely binary trees and more complicated \AVL
tree. The \AVL tree benchmarks demonstrate the ability of transformation of more
complicated code.

All measurements were done on \dots
\add{add description of machine ? }

\section{\textsc{sv-comp} benchmarks}

\begin{table}
\checkoddpage
\edef\side{\ifoddpage l\else r\fi}
\makebox[\textwidth][\side]{
\begin{minipage}[bt]{\fullwidth}
  \begin{center}
    \setlength{\tabcolsep}{0.5em}
    \begin{tabularx}{\textwidth}{l r r r r r X r r r r}
      \toprule
      & ~ & \multicolumn{4}{c}{\DIVINE + transformation} & ~ & \multicolumn{4}{c}{\SymDIVINE} \\
      \cmidrule(l){3-6}
      \cmidrule(l){8-11}
      & & valid & error & timeout & failed & & valid & error & timeout & failed \\
      \midrule
      pthreads & & $0$ & $0$ & $0$ & $0$ & & $0$ & $0$ & $0$ & $0$  \\
      loops & & $0$ & $0$ & $0$ & $0$ & & $0$ & $0$ & $0$ & $0$  \\
      recursion & & $0$ & $0$ & $0$ & $0$ & & $0$ & $0$ & $0$ & $0$  \\
      bitvector & & $0$ & $0$ & $0$ & $0$ & & $0$ & $0$ & $0$ & $0$  \\
      product-lines & & $0$ & $0$ & $0$ & $0$ & & $0$ & $0$ & $0$ & $0$  \\
      \bottomrule
    \end{tabularx}
  \end{center}
  \caption{For each benchmark set and each tool, the table provides the
    numbers of programs decided as valid, or with error, or undecided with the
        failed result or because of timeout.}
  \label{tbl:results}
\end{minipage}}
\end{table}

\add{ add qunatitative plot of benchmarks }

\section{Data structures}

The data structure benchmarks show the greatest contribution of a symbolic
approach. In real world a correctness of data structures is crucial. By symbolic
representation of elements in data structures we can verify all possible
behaviours for given amount of inputs. In these benchmarks we will demonstrate
how much time the transformation takes and how much time \DIVINE spends in
verification process. Because these benchmarks are in \Cpp, we can not compare
results with \SymDIVINE.

In all benchmarks we will try to verify insertions and deletions of arbitrary
values from the data structures. The data structures will be stored on the
stack, because we are limited in transformation by dynamic memory allocation.
We set naming convention for benchmarks as \code{\{name\}-\{num. of
insertion\}-\{num. of deletions\}-\{V/E for validity or error\}}.

\begin{table}
  \begin{center}
    \begin{tabularx}{\textwidth}{l r r r}
      \toprule
      Benchmark Name & Transformation & Verification & States \\
        \midrule
        \code{sorted-list-3-0-E} & $8.52s$ & $0.02s$ & $14$ \\
        \code{sorted-list-3-0-V} & $10s$ & $37s$ & $39$ \\
        \code{sorted-list-4-0-V} & $11.6s$ & $2m 14s$ & $155$ \\
        \code{sorted-list-5-0-V} & $9.04s$ & $8m 15s$ & $733$ \\
        \midrule

        \code{bintree-3-0-V} & $9.81s$ & $33.3s$ & $78$ \\
        \code{bintree-3-1-V} & $12.3s$ & $33.9s$ & $124$ \\
        \code{bintree-3-2-V} & $13s$ & $27s$ & $171$ \\
        \code{bintree-3-3-V} & $12.1s$ & $16s$ & $192$ \\

        \midrule

        \code{avl-1-0-V} & $6.15s$ & $1.93s$ & $16$ \\
        \code{avl-2-0-V} & $7.19s$ & $8.31s$ & $64$ \\
        \code{avl-3-0-V} & $7.96s$ & $39s$ & $346$ \\
        \code{avl-4-0-V} & $7.29s$ & $3m~27s$ & $1464$ \\
        \code{avl-5-0-V} & $6.89s$ & $14m~16s$ & $9242$ \\
      \bottomrule
    \end{tabularx}
  \end{center}
  \caption{Benchmarks of insertions and deletions from the data
    structures. A~name of benchmark represents a data structure, number of
    insertions and number of deletions. \code{V} or \code{E} at the end of
    name denotes whether the benchmark is valid or contains error.}
\end{table}

From the results we can see that bottleneck is still a verification. Although,
we have destroyed the data nondeterminism, we have brought a control flow
nondeterminism because of nondeterministic choices on branches. The transformation
time is steadily around 10seconds. An average speed of verification is 2 states
per second. We believe that this is consequence of slow \API between the model
checker and the \SMT solver. Since \SymDIVINE was able to generate 200 states
per seconds in average, with much less optimized exploration algorithm. Hence we
believe that in future we can optimize the algorithm to cope with larger state
spaces in reasonable time.

In benchmarks of the \AVL tree, we can see that despite the increasing number of inputs
the transformation time stays the same, but the verification time exponentially
grows. The exponential growth is caused by the nature of the \AVL tree. When we
are inserting an arbitrary value we have to branch the state space on each
comparison of the inserted value and node into which we are inserting. Branching
creates two possibilities, first when the value is inserted into the left
subtree and second for the right subtree. This way, we create during
verification all possible shapes of the \AVL tree for given amount of elements.
A similar phenomenon appears in other data structures, where the algorithm branches
depending on the inserted value.

But since the algorithms on these data structures are simple, the most of errors
are shallow and can be found much more faster than proving of correctness of
the algorithms.

During the evaluation we have encountered the qualities of the proposed
approach, because besides the verification of the program we have verified the
implementation of the abstraction and fix minor bugs that we have found. This
would not be possible if the abstraction would be implemented inside of the
verification tool.
